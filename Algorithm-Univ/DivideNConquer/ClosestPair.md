## 최근접 점의 쌍 찾기
---

### 1. 개념 🌱

2차원 평면 상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제

*분할 정복 알고리즘으로 문제에 접근하기 이전에 간단한 방법이 있는데 이는 모든 점에 대해 각각의 두 점 사이의 거리를 계산해 가장 가까운 점의 쌍을 찾는 방법이다. 이 방법의 시간 복잡도는 (비교 쌍의 개수) x (한 쌍의 거리 계산) => O(n^2)xO(1) = O(n^2)*

O(n^2)보다 효율적인 분할 정복 이용!!

<과정 및 알고리즘>

- n개의 점을 1/2로 분할하여 각각의 부분 문제에서 최근접 점의 쌍을 찾고, 2개의 부분 해 중에서 짧은 거리를 가진 점의 쌍을 일단 찾는다.

    ![스크린샷 2022-03-22 오후 7 11 10](https://user-images.githubusercontent.com/77239220/159457435-1321618d-1ae9-4a2e-906d-29367af2fa2c.png)

- 주의할 점은, 취합하는 과정에서 **중간 영역**을 고려해야 한다는 것. (10과 15 중에서 짧은 거리인 10 이내의 중간 영역 안에 있는 점들 중에 더 근접한 점의 쌍이 있는지 확인해야 함)
    
    ![스크린샷 2022-03-22 오후 7 13 45](https://user-images.githubusercontent.com/77239220/159457881-bf8efccd-77d6-4c40-962d-c7e7398c414a.png)

    > 중간 영역에 있는 점들?

    : 왼쪽 부분 문제의 가장 오른쪽 점(왼쪽 중간점)의 x좌표에서 d를 뺀 값과 오른쪽 부분 문제의 가장 왼쪽 점(오른쪽 중간점)의 x좌표에 d를 더한 값 사이의 x좌표 값을 가진 점들

    ![스크린샷 2022-03-22 오후 8 39 02](https://user-images.githubusercontent.com/77239220/159473567-6c48fa6b-0acb-4cfe-9f2a-1305c8134b56.png)

- 알고리즘
    
        ClosestPair(S)
        1. if (i ≤ 3) return (2 또는 3개의 점들 사이의 최근접 쌍)
        2. 정렬된 S를 같은 크기의 SL과 SR로 분할한다. |S|가 홀수이면 |SL| = |SR|+1이 되도록.
        3. CPL = ClosestPair(SL)  // CPL은 SL에서의 최근접 점의 쌍
        4. CPR = ClosestPair(SR)  // CPR은 SR에서의 최근접 점의 쌍
        5. d = min{dist(CPL), dist(CPR)}일 때, 중간 영역에 속하는 점들 중에서 최근접 점의 쌍을 찾아서 이를 CPC라고 하자.
        6. return (CPL, CPC, CPR 중에서 거리가 가장 짧은 쌍)

### 2. 시간 복잡도 ⏰

- S에 n개의 점이 있으면 전처리 과정으로서 x좌표로 정렬
    
    -> O(nlogn)

- 1번 과정 : 점이 3개 -> 거리 계산 3회 / 2개 -> 거리 계산 1회

    -> O(1)

- 2번 과정 : 정렬된 S를 분할하는 과정에서 이미 배열에 정렬되어 있으므로 배열의 중간 인덱스로 분할하면 됨
    
    -> O(1)

- 3~4번 과정 : SL, SR 에 대해 각각 ClosestPair를 재귀 호출하는데 분할하며 호출되는 과정은 합병 정렬과 동일

- 5번 과정 : d = min{dist(CPL), dist(CPR)}일 때 중간 영역에
속하는 점들 중에서 최근접 점의 쌍을 찾음
    
        how??
        -> 중간영역에 있는 점들을 y좌표 기준으로 정렬한 후, 아래에서 위로 각 점을 기준으로 거리가 d 이내인 주변의 점들 사이의 거리를 각각 계산하며, 이 영역에 속한 점들 중에서 최근접 점의 쌍을 찾는다.
    
    -> y좌표로 정렬하는데 O(nlogn) 시간이 걸리고, 아래에서 위로 올라가며 각 점에서 주변의 점들 사이의 거리를 계산하는데 O(1) 시간 소요 (각 점과 거리 계산해야 하는 주변 점들의 수는 O(1)개이기 때문)

- 6번 과정 : 3개의 점의 쌍 중에 가장 짧은 거리를 가진 점의 쌍을 리턴

    -> O(1)

> 최종

ClosestPair 알고리즘의 분할 과정은 합병 정렬의 분할 과정과 동일하다. 그러나 ClosestPair 알고리즘에서는 해를 취합하여 올라가는 과정인 5~6번 과정에서 O(nlogn) 시간이 필요하다.

따라서

    - 각 층의 수행 시간은 O(nlogn)
    - 여기에 층 수인 logn을 곱하면 O(n(logn)^2)


### 3. 코드 🧑‍💻

- C언어
    
    [컴알 chap3_2 ClosestPair.c](https://github.com/julia-ing/CS-Study/blob/main/Algorithm-Univ/DivideNConquer/ClosestPair.c)

- 파이썬
    
    [백준 2261번 문제](https://www.acmicpc.net/problem/2261) 참고 -> 푼 이후 코드 업로드 예정
