## 시스템 구조와 프로그램 실행
---

![스크린샷 2022-03-20 오전 12 20 01](https://user-images.githubusercontent.com/77239220/159127020-b5279ae6-bb61-41cd-8f54-f08511255594.png)

## 1. Mode bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치

- Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원함

        1 사용자 모드 : 사용자 프로그램 수행
        0 모니터 모드 (커널모드, 시스템 모드) : OS 코드 수행
- 보안을 해칠 수 있는 중요한 명령어는 커널 모드에서만 수행 가능한 **특권명령** 으로 규정

- Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꾸고 / 
사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 세팅한다.
    ![스크린샷 2022-03-20 오전 12 29 40](https://user-images.githubusercontent.com/77239220/159127420-11de929e-28ba-45de-8fde-c9be422e6ced.png)

## 2. Timer 

- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시키는 인터럽터 역할. 타이머 값이 0이 되면 타이머 인터럽트가 발생한다.
- CPU를 특정 프로그램이 독점하는 것으로부터 보호함
- time sharing 구현을 위해 사용

## 3. Device Controller

- **I/O device controller**
    
    해당 I/O 장치유형을 관리하는 일종의 **작은 CPU**로, 제어 정보를 위해 control register, status register를 가지며 local buffer를 가짐 (일종의 data register)

- I/O는 실제 device와 local buffer 사이에서 일어난다.

- Device Controller는 입출력이 끝났을 경우 인터럽트로 CPU에 그 사실을 알린다. 
    
    cf) CPU가 interrupt를 너무 많이 당하는 현상이 발생하여 CPU가 비효율적으로 작동함 -> 이후 DMA 개념 등장

- device driver 와 비교

        device driver (장치 구동기) : OS가 각 장치를 구동/처리시키는 루틴, 즉 소프트웨어. CPU가 장치를 어떻게 처리해야 하는지 알려주는 명세서 역할을 함
        
        device controller (장치 제어기) : 각 장치를 통제하는 일종의 작은 CPU, 즉 하드웨어.

## 4. 입출력(I/O)의 수행

- **모든 입출력 명령은 특권 명령**

- 사용자 프로그램은 어떻게 I/O를 하는가?

    -> 시스템 콜(system call) : 사용자 프로그램은 운영체제에게 I/O 요청

    -> trap을 사용하여 인터럽트 벡터의 특정 위치로 이동

    -> 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동

    -> 올바른 I/O 요청인지 확인 후 I/O 수행

    -> I/O 완료 시 제어권을 시스템 콜 다음 명령으로 옮김

## 5. 인터럽트 (Interrupt)

- CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에 예외 상황이 발생하여 처리가 필요할 경우에 CPU가 처리할 수 있도록 알리는 것. 운영체제는 인터럽트에 의해 구동된다!!

- 인터럽트 당한 시점의 **레지스터**와 PC(**Program Counter**)를 저장한 후 CPU의 제어를 **인터럽트 처리 루틴**에 넘긴다.

<분류>

1. 하드웨어 인터럽트 (Interrupt) : 하드웨어가 발생시킨 인터럽트

2. 소프트웨어 인터럽트 (Trap) : 프로그램이 오류를 범하여 **Exception**이 발생하거나 / 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 **System Call**이 발생하는 경우

> 인터럽트 발생 시 처리 과정

1. 현재 실행 중인 명령의 메모리 주소를 포함한 부가 정보를 저장한다. 

    CPU에서 명령이 실행될 때 CPU 내부에 있는 임시 기억장치인 "레지스터"에 데이터를 read/write 한다. 이때 인터럽트가 발생하면 기존의 레지스터값들이 지워지게 되므로 CPU 내의 이러한 상태를 PCB에 저장한다.

    -> 
    ### **PCB (프로세스 제어 블록)**
    
        PCB는 프로그램마다 하나씩 존재하는데, PCB에는 해당 프로그램의 어느 부분이 실행 중이었는지를 저장한다.
        
        저장 내용: 실행중이던 코드의 <메모리 주소, 레지스터 값, 하드웨어 상태 등>

2. 인터럽트 처리 루틴 (ISR) 커널 함수로 해당 인터럽트를 처리한다.

    운영체제는 할 일을 쉽게 찾아가기 위해 **인터럽트 벡터(interrupt vector)**를 가지고 있다. 인터럽트 백터는 해당 인터럽트의 처리 루틴 주소를 가리키는 자료구조이다.
    
    인터럽트 백터를 따라가면 실제 처리해야 할 코드는 인터럽트 처리 루틴 (=인터럽트 핸들러) 에 정의된다.

3. 인터럽트 당하기 직전으로 복원한다.

    인터럽트 처리 완료 후에는 원래 수행하던 작업으로 돌아가 (PCB에 저장된 정보) 중단되었던 일을 다시 수행한다.

## 6. 동기 / 비동기

### 동기식 입출력 (synchronous I/O)

- I/O 요청 후 입출력 작업이 **완료된 후에야** 제어가 사용자 프로그램으로 넘어감

### 비동기식 입출력 (asynchronous I/O)

- I/O 가 시작된 후 입출력 작업이 끝나기를 **기다리지 않고** 제어가 사용자 프로그램으로 즉시 넘어감 (작업 완료 여부를 신경쓰지 않음)


-> 요청 이후에 CPU 가 다른 명령을 실행할 수 있으면 비동기, 아니면 동기다.

-> 두 경우 모두 I/O의 완료는 인터럽트로 알려줌

---
<참고> - Blocking / Non-Blocking

[읽어보면 좋을 링크](https://velog.io/@wonhee010/%EB%8F%99%EA%B8%B0vs%EB%B9%84%EB%8F%99%EA%B8%B0-feat.-blocking-vs-non-blocking)

||**동기**|**비동기**|**Blocking**|**Non-Blocking**|
|------|---|---|---|---|
|**제어권 반납**|I/O 완료 후|즉시|I/O 완료 후|즉시|
|**I/O 진행 중 CPU**|다른 프로세스 수행|기존 프로세스 수행|일시정지|I/O 완료 확인 반복|
|**I/O 완료 알림**|인터럽트로 알림|인터럽트로 알림|I/O 결과 반환|I/O 결과 반환|

---

## 7. DMA (Direct Memory Access)

CPU가 interrupt를 너무 많이 당함 -> CPU 효율성 떨어짐

**CPU의 중재 없이** device controller가 디바이스의 buffer storage의 내용을 메모리에 **block 단위**로 직접 전송하고,
CPU에게 interrupt를 걸어서 메모리에 올라왔다고 보고한다.

(CPU는 스타트만 해주고 권한을 DMA에 바로 넘긴다.)

## 8. 입출력의 두 가지 방식

<img width="476" alt="스크린샷 2022-03-26 오전 2 17 30" src="https://user-images.githubusercontent.com/77239220/160169908-a3fdd246-b9b1-4e75-91f6-44d191b4e9f4.png">

1. 메모리만 접근하는 명령어, I/O만 접근하는 명령어가 나눠져있는 경우 -> I/O를 수행하는 special instruction을 통해 I/O device에 접근함

2. Memory Mapped I/O : I/O device들에 메모리 주소를 할당해 memory 접근 instruction을 통해 한번에 접근 가능 (전부 메모리 주소로 보는 관점)

## 9. 저장장치 계층 구조

<img width="672" alt="스크린샷 2022-03-26 오전 2 26 59" src="https://user-images.githubusercontent.com/77239220/160171378-d0285e15-12c9-441a-bbb2-473a95c53b1b.png">

위로 갈수록 속도가 빠르고 비용이 높다. 

위 세 개는 휘발성 부분이며 primary(executable) -> CPU가 직접 제어 가능한 부분이다. 

참고 **Cache**: 

    CPU의 처리 속도와 주기억장치의 접근 속도 차이를 줄이기 위해 사용하는 고속 Buffer Memory

    - 원하는 정보가 이전에 저장된 데이터였다면, 즉 캐시 메모리에 기억되어 있었을 때 적중(Hit)되었다고 한다. (적중률은 캐시 기억장치가 있는 컴퓨터의 성능을 나타내는 척도로 높을수록 우수)
    
    ※ 적중률 (Hit Ratio) = 적중 횟수 / 총 접근 횟수  

## 10. 프로그램의 실행 (메모리 load)

<img width="686" alt="스크린샷 2022-03-26 오전 2 47 18" src="https://user-images.githubusercontent.com/77239220/160174461-beb49d13-c378-4aab-a707-3cdef5627c30.png">

프로그램은 실행파일의 형태로 disk에 저장된다. 이를 실행시키게 되면 메모리로 올라가고, 프로세스가 된다.

프로그램을 실행시키면 프로그램만의 독자적인 메모리 주소공간(Address space, virtual memory)이 형성되는데 주소공간은 **code, data, stack**으로 구성된다.

각 주소공간을 모두 다 물리적인 메모리 공간에 올리지 않고 필요할 때마다 사용한다.

당장 사용하지 않는 부분은 disk의 Swap area에 저장되며
Swap area로 사용하는 하드디스크는 휘발성이다. (File system을 저장하는 disk는 비휘발성이므로 구분 필요).

## 11. 커널 주소 공간의 내용

위의 그림에서 커널의 경우 **Kernel Address Space**에 저장된다.

### code

- cpu 등 컴퓨터의 자원 관리를 위한 코드
- 시스템콜, 인터럽트 처리 코드

### data

- PCB(Process Control Block) - 실행된 프로그램마다 이를 관리하기 위한 자료구조가 있는데 이 PCB가 커널에 만들어진다.

### stack

- 사용자 프로그램마다 kernel stack을 따로 갖는다. 어떤 process가 커널 함수를 사용했는지 stack에 저장한다.

## 12. 사용자 프로그램이 사용하는 함수

모든 프로그램은 함수 형태로 작성된다.

- 사용자 정의 함수 : 자신의 프로그램에서 정의한 함수

- 라이브러리 함수 : 자신의 프로그램에서 정의하지 않고 가져다 쓴 함수, 자신의 프로그램 실행 파일에 포함되어 있음

- 커널 함수 : 운영체제 프로그램의 함수

    커널 함수의 호출 = system call
