# 화일 종류 비교

## 💡 히프화일


- 레코드들이 삽입된 순서대로 화일에 저장
- 삽입은 효율적이지만, 검색/삭제 는 비효율적
    
    모든 레코드들을 순차적으로 검색해야 하고 삭제같은 경우는 삭제된 레코드가 차지하던 공간을 재사용하지 않는다.
    
    가장 효율적인 경우는 질의에서 모든 레코드들을 참조하고 레코드의 순서는 중요하지 않은 상황
    

> if <레코드 10,000,000개 / 레코드 길이 200바이트 / 블록 4,096 바이트>

`블로킹 인수` 4,096/200 = 20 (한 블록에 포함되는 레코드 수: 블록 / 레코드 길이)

`블록 수` 10,000,000/20 = 500,000개 (레코드 개수 / 블로킹 인수)

`특정 레코드를 찾기 위해서 읽어야 하는 디스크 블록` 500,000/2 = 250,000

`총 걸리는 시간` 250,000*10ms = 2,500,000ms = 2500초 

---

## 💡 순차화일


- 레코드들이 하나 이상의 필드 값에 따라 순서대로 저장된 화일
    - 일반적으로 레코드의 **탐색 키(순차 화일을 정렬하는데 사용되는 필드)** 값의 순서에 따라 저장
- 탐색키 기반으로 탐색하는 데는 효율적, 삽입/삭제 는 비효율적
    
    삽입하려는 레코드의 순서를 고려해야 하므로 시간이 많이 소요되고, 삭제같은 경우 히프 화일과 마찬가지 → 주기적으로 재조직해야 함
    
    기본 인덱스가 순차화일에 정의되지 않는 한 DB에 거의 사용되지 X
    
- 이진 탐색 사용 가능(저장 순서와 관련 있는 SELECT 문에 대해)

> if <레코드 10,000,000개 / 레코드 길이 200바이트 / 블록 4,096 바이트>

`블로킹 인수` 4,096/200 = 20 (한 블록에 포함되는 레코드 수: 블록 / 레코드 길이)

`블록 수` 10,000,000/20 = 500,000개 (레코드 개수 / 블로킹 인수)

`특정 레코드를 찾기 위해서 읽어야 하는 디스크 블록` log2(500,000) = 19 (이진 탐색 사용 시)

`총 걸리는 시간` 19*10ms = 190ms 

---

## 💡 단일 단계 인덱스 (인덱스된 순차화일)


- 인덱스를 통해 임의의 레코드를 접근할 수 있는 화일
    - 각 엔트리는 <탐색 키, 레코드에 대한 포인터>
    - 탐색 키: 인덱스가 정의된 필드, 각 투플마다 항상 고유하지는 않고 키를 구성하는 attribute 뿐 아니라 어떤 attribute도 탐색 키로 사용 가능 ++ 인덱스의 엔트리들은 탐색 키 값의 오름차순 저장 → 이진 탐색 사용 가능
        
        ![스크린샷 2022-05-31 오전 2 45 42](https://user-images.githubusercontent.com/77239220/171040316-dbe2bf77-19a8-4fef-b249-5aca6b09f1c5.png)
        
- 인덱스는 데이터 화일과 **별도** 의 화일에 저장됨!! 인덱스 크기는 훨씬 작으며, 하나의 화일에 여러 인덱스 정의 가능
    - **기본 인덱스**
        
        탐색 키가 데이터 화일의 기본 키인 인덱스
        
        흔히 희소 인덱스로 유지 가능: 각 릴레이션마다 최대 한 개의 기본 인덱스를 가질 수 있음 
        
        ![스크린샷 2022-05-31 오전 2 45 53](https://user-images.githubusercontent.com/77239220/171040337-419cd35e-1c82-4011-9b44-99587efdb250.png)
        
        > if <레코드 10,000,000개 / 레코드 길이 200바이트 / 블록 4,096 바이트 / 인덱스 엔트리 길이 24 바이트>
        
        `블로킹 인수` 4,096/200 = 20 (한 블록에 포함되는 레코드 수: 블록 / 레코드 길이)
        
        `블록 수` 10,000,000/20 = 500,000개 (레코드 개수 / 블로킹 인수)
        
        `인덱스 블로킹 인수` 4,096/24 = 170 (블록 / 인덱스 엔트리 길이)
        
        `인덱스 블록 수` 500,000/170 = 2942 블록 (블록 수 / 인덱스 블로킹 인수)
        
        `인덱스로 하나의 레코드를 찾는 데 필요한 블록 접근 횟수` log2(2,942) + 1 = 13 (이진 탐색 사용 시)
        
        `총 걸리는 시간` 13*10ms = 130ms 
        
    - **클러스터링 인덱스**
        
        탐색 키 값에 따라 정렬된 데이터 화일에 대해 정의됨
        
        각각 상이한 키 값마다 하나의 인덱스 엔트리가 인덱스에 포함됨 - 범위 질의에 유용 (범위 시작 값에 해당하는 인덱스 엔트리를 먼저 찾고 따라가면서 검색하면 디스크에서 읽어오는 블록 수가 최소화)
        
        ![스크린샷 2022-05-31 오전 2 46 04](https://user-images.githubusercontent.com/77239220/171040361-4ec85334-8aad-4df0-8afb-9a3319522765.png)
        
        > if <레코드 10,000,000개 / 레코드 길이 200바이트 / 블록 4,096 바이트 / 인덱스 엔트리 길이 24 바이트 / 서로 상이한 탐색 키 값들의 수 800,000개>
        
        `블로킹 인수` 4,096/200 = 20 (한 블록에 포함되는 레코드 수: 블록 / 레코드 길이)
        
        `인덱스 블로킹 인수` 4,096/24 = 170 (블록 / 인덱스 엔트리 길이)
        
        `인덱스 블록 수` 800,000/170 = 4,706 블록 (서로 상이한 탐색 키 값들의 수 / 인덱스 블로킹 인수)
        
        `인덱스로 하나의 레코드를 찾는 데 필요한 블록 접근 횟수` log2(4,706) + 1 = 14 (이진 탐색 사용 시)
        
        `총 걸리는 시간` 14*10ms = 140ms 
        
    - **보조 인덱스**
        
        탐색 키 값에 따라 정렬되지 않은 데이터 화일에 대해 정의
        
        일반적으로 밀집 인덱스 → 기본 인덱스보다 디스크 접근 횟수가 증가할 수 있음
        
        ![스크린샷 2022-05-31 오전 2 46 15](https://user-images.githubusercontent.com/77239220/171040376-6ea800e7-4695-4295-a54d-512c824297a5.png)
        
        > if <레코드 10,000,000개 / 레코드 길이 200바이트 / 블록 4,096 바이트 / 인덱스 엔트리 길이 24 바이트>
        
        `블로킹 인수` 4,096/200 = 20 (한 블록에 포함되는 레코드 수: 블록 / 레코드 길이)
        
        `인덱스 블로킹 인수` 4,096/24 = 170 (블록 / 인덱스 엔트리 길이)
        
        `인덱스 블록 수` 10,000,000/170 = 58,824 블록 (레코드 개수 / 인덱스 블로킹 인수)
        
        `인덱스로 하나의 레코드를 찾는 데 필요한 블록 접근 횟수` log2(58,824) + 1 = 17 (이진 탐색 사용 시)
        
        `총 걸리는 시간` 17*10ms = 170ms 
        
- 인덱스 비교
    - 희소 VS 밀집(보조)
        
        희소는 각 **데이터 블록**마다 한 개의 엔트리를 찾고 밀집은 각 **레코드**마다 한 개의 엔트리를 가짐
        
        일박적으로 희소 인덱스의 엔트리 수가 밀집보다 훨씬 적고 디스크 접근 수도 1만큼 적음 / 대부분의 질의에 대해 희소가 더 효율적 
        
        밀집 인덱스가 더 효율적인 경우? - 질의에서 인덱스가 정의된 애트리뷰트만 검색 (ex: COUNT)하는 경우 데이터 화일 접근 필요 없이 인덱스만 접근해 수행 가능하므로 밀집이 더 유리
        
        *한 화일은 한 개의 희소 인덱스와 다수의 밀집 인덱스 가질 수 있다*
        
    - 밀집(보조) VS 클러스터링
        
        클러스터링은 희소 인덱스인 경우가 많고 범위 질의에 좋음
        
---

## 💡 다단계 인덱스


- 인덱스 자체가 크면 인덱스 탐색 시간도 오래 걸린다 → 인덱스 엔트리를 탐색하는 시간을 줄이기 위해, 단일 단계 인덱스에 대해 다시 인덱스 정의
    
    가장 상위 단계(마스터 인덱스, 주기억 장치에 상주 가능)의 모든 인덱스 엔트리들이 한 블록에 들어갈 수 있을 때까지 반복 
    
    대부분 B+ 트리 사용
    
    > if <레코드 10,000,000개 / 레코드 길이 200바이트 / 블록 4,096 바이트>
    
    `블로킹 인수` 4,096/200 = 20 (한 블록에 포함되는 레코드 수: 블록 / 레코드 길이)
    
    `블록 수` 10,000,000/20 (레코드 / 블로킹 인수) = 500,000 개
    
    `1단계 인덱스 블록 수` 500,000/170 = 2,942 블록 (블록 수 / 인덱스 블로킹 인수)
    
    `2단계 인덱스 블록 수` 2,942/170 = 18 블록 (1단계 인덱스 블록 수 / 인덱스 블로킹 인수)
    
    `1단계 인덱스 블록 수` 18/170 = 1 블록 (2단계 인덱스 블록 수 / 인덱스 블로킹 인수)
    
    `각 인덱스 블록 접근 횟수` 1+1+1 = 3 
    
    `총 걸리는 시간` 3*10ms = 30ms 
    
---

## 💡 SQL 정의


DBMS 자동 설정 : PK - 기본 인덱스, UNIQUE - 보조 인덱스

`CREATE INDEX EmpIndex ON EMPLOYEE(DNO, SALARY);`

이 인덱스는 다음 질의에 활용될 수 있음 :

SELECT *

FROM EMPLOYEE

WHERE DNO = 3 AND SALARY = 4000000;

다음 질의에는 활용될 수 없음 :

SELECT *

FROM EMPLOYEE

WHERE SALARY >= 3000000 AND SALARY <= 4000000;

→ 첫번째가 꼭 포함되어 있어야 함!!

---

## 💡 인덱스 정리

장점 : 

- 검색 속도 향상
- 소수의 레코드들 수정/삭제 속도 향상
- 릴레이션이 매우 크고 / 질의에서 릴레이션의 투플들 중 일부를 검색하고 / WHERE절이 잘 표현되었을 때 특히 성능에 도움

단점 :

- 인덱스 저장을 위한 공간이 추가로 필요
- 삽입 / 삭제 / 수정 연산 속도는 저하시킴
- 기술 면접 대비
    1. 인덱스 설명
        - 테이블의 검색 속도를 높여주는 자료 구조
        - 인덱스는 데이터의 위치를 빠르게 찾아주는 역할을 한다. 만약 index를 사용하지 않은 컬럼을 조회해야하는 상황이라면 전체를 탐색하는 full scan을 수행해야 하는데 full scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다. 반면에 인덱스를 사용하면 인덱스는 정렬되어 있다는 특징도 가지고 있기 때문에 탐색에 굉장히 유리!
        - 인덱스를 사용하면 좋은 경우는 DML 연산이 적은 경우나 데이터 중복이 적은 경우
    2. DML 연산이 빈번한 컬럼에 인덱스를 걸게 되면 성능이 오히려 저하되는 역효과
        - UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 "사용하지 않음" 처리를 해주는데, 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 예를 들어 10만건인 반면에 인덱스는 100만건이 될 수가 있고, 따라서 SQL문 처리시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 됨.
    3. 효율적 인덱스를 위한 4가지 기준
        - 카디널리티 (높을수록) - 한 컬럼이 갖고 있는 값의 중복 정도가 낮을 수록 좋음
        - 선택도 (낮을수록) - 선택되는 레코드 수 / 테이블 전체 레코드 수
        - 활용도 (높을수록)
        - 중복도 (낮을수록)
    4. 자료구조 (해시테이블과 B+ Tree)
        - 해시테이블은 key, value로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. 해시 테이블은 Key 값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조임. 하지만 해시가 등호(=) 연산에만 특화되어있기 때문에 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산(>,<)이 자주 사용되는 데이터베이스 검색을 위해서는 해시테이블이 적합하지 않음!!
        - B Tree는 이진트리를 확장해서 더 많은 수의 자식을 가질 수 있게 일반화시키고 트리의 균형을 자동으로 맞춰주는 자료구조이고 B+ 트리는 B 트리의 변형구조로, 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드가 추가로 있음

- 인덱스 선정 정리
    
    가장 중요한 질의 / 갱신 에 대한 수행 빈도를 고려해 선정
    
    **선정 지침**
    
    1. 기본 키는 클러스터링 인덱스를 정의할 훌륭한 후보
    2. 외래 키도 인덱스를 정의할 중요한 후보
    3. 한 애트리뷰트에 들어 있는 상이한 값들의 개수가 거의 전체 레코드 수와 비슷하고, 그 애트리뷰트가 동등 조건에 사용된다면 비클러스터링 인덱스를 생성하는 것이 좋음
    4. 투플이 많이 들어있는 릴레이션에서 대부분의 질의가 검색하는 투플이 2~4% 미만인 경우 인덱스 생성
    5. 자주 갱신되는 애트리뷰트에는 인덱스 정의하지 않는게 좋음
    6. 갱신이 빈번하게 이루어지는 릴레이션에는 인덱스를 많이 만들지 않도록 함
    7. 후보 키도 인덱스 생성 후보
    8. 인덱스는 화일의 레코드들을 충분히 분할할 수 있어야 함
    9. 정수형 애트리뷰트에 인덱스 생성
    10. VARCHAR 애트리뷰트에는 만들지 않음
    11. 작은 화일에는 인덱스 만들 필요 X
    12. 대량의 데이터 삽입 시 모든 인덱스를 제거하고, 삽입이 끝나면 다시 생성
    
    **인덱스가 사용되지 않는 경우**
    
    - 릴레이션 크기가 작아 인덱스가 도움되지 않다고 판단되는 경우
    - 인덱스가 정의된 애트리뷰트에 산술 연산자가 사용됨
    - DBMS가 제공하는 내장함수가 집단 함수 대신 사용됨 (ex: SUBSTR)
    - 널값
    

---

## 💡 질의 튜닝

- DISTINCT 절 사용 최소화
- GROUP BY와 HAVING 사용 최소화
- 임시 릴레이션 사용 피하기
- SELECT * 대신 구체적 명시

